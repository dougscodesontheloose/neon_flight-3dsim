<html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Flight Sim 1984 - FIXED</title>
    <style>
        /* --- RETRO CSS --- */
        body { 
            margin: 0; overflow: hidden; 
            background: #050011; 
            font-family: 'Courier New', Courier, monospace; 
            user-select: none; 
        }
        
        /* CRT Scanline Overlay */
        body::after {
            content: " ";
            display: block;
            position: absolute; top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), 
                        linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 20; background-size: 100% 2px, 3px 100%; pointer-events: none;
        }

        /* UI ELEMENTS */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 0, 20, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: #fff; text-align: center; cursor: pointer;
        }
        #start-screen h1 { 
            font-size: 60px; margin: 0; color: #f0f; text-shadow: 4px 4px 0px #0ff; 
            font-style: italic; letter-spacing: 5px; text-transform: uppercase;
        }
        .blink { animation: blink 1s step-end infinite; color: #ff0; margin-top: 20px; font-size: 20px; }
        @keyframes blink { 50% { opacity: 0; } }

        #hud, #ui-layer, #controls-help {
            position: absolute; z-index: 30;
            background: rgba(0,0,0,0.8); border: 2px solid #0ff;
            box-shadow: 0 0 10px #0ff, inset 0 0 10px rgba(0,255,255,0.2);
            padding: 15px; color: #0ff;
        }
        
        #hud { top: 20px; left: 20px; border-color: #f0f; box-shadow: 0 0 10px #f0f; color: #f0f; }
        #ui-layer { top: 20px; right: 20px; width: 200px; }
        #controls-help { bottom: 20px; left: 20px; border-color: #ff0; box-shadow: 0 0 10px #ff0; color: #fff; font-size: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }

        /* FORM ELEMENTS */
        select { 
            background: #000; color: #0ff; border: 1px solid #0ff; 
            padding: 5px; width: 100%; margin-bottom: 10px; 
            font-family: inherit; cursor: pointer; outline: none;
        }
        label { font-size: 10px; color: #fff; letter-spacing: 1px; }
        .key { background: #222; padding: 2px 5px; border: 1px solid #ff0; color: #ff0; }
        .active-key { background: #ff0; color: #000; }

    </style>

    <!-- Import Map for Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

<!-- LAYOUT -->
<div id="start-screen">
    <h1>NEON FLIGHT</h1>
    <p style="color:#0ff; letter-spacing:2px;">INSERT COIN // SYSTEM READY</p>
    <div class="blink">CLICK TO START</div>
</div>

<div id="hud">
    <div style="border-bottom:2px solid #f0f; margin-bottom:5px; font-weight:bold;">SYSTEM DATA</div>
    SPD: <span id="speedVal" style="color:#fff">0</span> <span style="font-size:10px">MACH</span><br>
    ALT: <span id="altVal" style="color:#fff">0</span> <span style="font-size:10px">FT</span><br>
    STS: <span id="statusVal" style="color:#fff">DOCKED</span>
</div>

<div id="ui-layer">
    <label>SHIP CLASS</label>
    <select id="planeSelect">
        <option value="TRAINER">Vector Mk1 (Balanced)</option>
        <option value="JET">Interceptor (Fast)</option>
        <option value="BIPLANE">Glider-X (Floaty)</option>
    </select>
    <label>HYPERDRIVE</label>
    <select id="speedSelect">
        <option value="0.5">50% (Chill)</option>
        <option value="1.0" selected>100% (Synth)</option>
        <option value="1.5">150% (Turbo)</option>
        <option value="2.0">200% (Outrun)</option>
    </select>
</div>

<div id="controls-help">
    <div>
        <b style="color:#ff0">THRUST</b><br>
        <span id="key-w" class="key">W</span> Accel<br>
        <span id="key-s" class="key">S</span> Decel<br>
        <span id="key-down" class="key">↓</span> Pitch Up<br>
        <span id="key-up" class="key">↑</span> Pitch Down
    </div>
    <div>
        <b style="color:#ff0">VECTOR</b><br>
        <span id="key-left" class="key">←</span> Bank L<br>
        <span id="key-right" class="key">→</span> Bank R<br>
        <span id="key-space" class="key">SPC</span> Brake
    </div>
</div>

<!-- GAME ENGINE -->
<script type="module">
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    // --- CONSTANTS ---
    const WORLD_SIZE = 6000;
    const RUNWAY_LENGTH = 2000;
    const GRAVITY = 0.02;
    
    // Colors
    const C_PINK = 0xff00ff;
    const C_CYAN = 0x00ffff;
    const C_LIME = 0xbfff00;
    const C_VOID = 0x050011;

    const AIRCRAFT = {
        TRAINER: { maxSpeed: 4.0, accel: 0.01, liftCoeff: 0.03, turnSpeed: 0.03, color: C_CYAN, model: createTrainer },
        JET: { maxSpeed: 7.5, accel: 0.03, liftCoeff: 0.018, turnSpeed: 0.05, color: C_PINK, model: createJet },
        BIPLANE: { maxSpeed: 2.5, accel: 0.008, liftCoeff: 0.05, turnSpeed: 0.025, color: C_LIME, model: createBiplane }
    };

    // --- STATE ---
    let scene, camera, renderer;
    let planeGroup, blimpGroup;
    let gridHelper, sunMesh;
    
    let gameRunning = false;
    let speed = 0;
    let speedMult = 1.0;
    let currentStats = AIRCRAFT.TRAINER;
    
    const inputs = { w:0, s:0, up:0, down:0, left:0, right:0, brake:0 };

    // --- DOM ---
    const uiSpeed = document.getElementById('speedVal');
    const uiAlt = document.getElementById('altVal');
    const uiStatus = document.getElementById('statusVal');
    
    init();
    animate();

    function init() {
        // 1. Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(C_VOID);
        scene.fog = new THREE.FogExp2(C_VOID, 0.0012); // Dense fog for infinite look

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 8000);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. Light
        const ambient = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambient);
        
        const sunLight = new THREE.DirectionalLight(C_PINK, 1.5);
        sunLight.position.set(0, 500, -1000);
        scene.add(sunLight);

        // 3. World
        buildWorld();
        createBlimp();
        spawnPlane('TRAINER');

        // 4. Events
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('keydown', (e) => handleInput(e, true));
        window.addEventListener('keyup', (e) => handleInput(e, false));
        
        document.getElementById('start-screen').addEventListener('click', startGame);
        document.getElementById('planeSelect').addEventListener('change', (e) => { spawnPlane(e.target.value); window.focus(); });
        document.getElementById('speedSelect').addEventListener('change', (e) => { speedMult = parseFloat(e.target.value); window.focus(); });
    }

    function startGame() {
        gameRunning = true;
        document.getElementById('start-screen').style.display = 'none';
    }

    function handleInput(e, isDown) {
        const k = e.key.toLowerCase();
        const c = e.code;
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();

        if(c === 'Space' && isDown && !gameRunning) { startGame(); return; }
        if(!gameRunning) return;

        if(k==='w') setIn('w', isDown, 'key-w');
        if(k==='s') setIn('s', isDown, 'key-s');
        if(c==='ArrowUp') setIn('up', isDown, 'key-up');
        if(c==='ArrowDown') setIn('down', isDown, 'key-down');
        if(c==='ArrowLeft'||k==='a') setIn('left', isDown, 'key-left');
        if(c==='ArrowRight'||k==='d') setIn('right', isDown, 'key-right');
        if(c==='Space') setIn('brake', isDown, 'key-space');
    }

    function setIn(prop, val, id) {
        inputs[prop] = val;
        const el = document.getElementById(id);
        if(el) val ? el.classList.add('active-key') : el.classList.remove('active-key');
    }

    // --- PHYSICS LOOP ---
    function update() {
        if(!gameRunning) {
            // Attract Mode Camera
            if(planeGroup) {
                const t = Date.now() * 0.0005;
                camera.position.set(
                    planeGroup.position.x + Math.cos(t)*40,
                    planeGroup.position.y + 15,
                    planeGroup.position.z + Math.sin(t)*40
                );
                camera.lookAt(planeGroup.position);
            }
            return;
        }

        if(!planeGroup) return;

        // 1. Speed
        const maxS = currentStats.maxSpeed * speedMult;
        const acc = currentStats.accel * speedMult;
        
        if(inputs.w && speed < maxS) speed += acc;
        if(inputs.s && speed > 0) speed -= acc;
        if(inputs.brake && speed > 0) speed -= 0.05 * speedMult;
        if(speed < 0) speed = 0;

        planeGroup.translateZ(speed);

        // 2. Control
        const auth = Math.min(speed/2, 1.0);
        const tr = currentStats.turnSpeed * auth * speedMult;

        if(inputs.down) planeGroup.rotateX(-tr);
        if(inputs.up) planeGroup.rotateX(tr);
        if(inputs.left) planeGroup.rotateZ(tr);
        if(inputs.right) planeGroup.rotateZ(-tr);

        // Auto-Level
        planeGroup.rotation.y += -planeGroup.rotation.z * 0.015 * auth;
        if(!inputs.left && !inputs.right) planeGroup.rotation.z *= 0.98;
        if(!inputs.up && !inputs.down) planeGroup.rotation.x *= 0.99;

        // 3. Lift/Gravity
        const lift = speed * currentStats.liftCoeff;
        const upVec = new THREE.Vector3(0,1,0).applyQuaternion(planeGroup.quaternion);
        const vForce = (lift * upVec.y) - GRAVITY;
        planeGroup.position.y += vForce * 10;

        // Floor
        if(planeGroup.position.y < 1.5) {
            planeGroup.position.y = 1.5;
            planeGroup.rotation.x *= 0.9;
            planeGroup.rotation.z *= 0.9;
            if(!inputs.w) speed *= 0.98;
        }

        // 4. VISUAL FIXES
        
        // Infinite Grid Snapping (The Fix for "Frozen" ground)
        // We snap the grid position to the nearest 50 units relative to plane
        // This ensures the grid lines always appear moving
        if(gridHelper) {
            const cellSize = 50;
            gridHelper.position.x = Math.floor(planeGroup.position.x / cellSize) * cellSize;
            gridHelper.position.z = Math.floor(planeGroup.position.z / cellSize) * cellSize;
        }

        // Sun follows on horizon
        if(sunMesh) {
            sunMesh.position.x = planeGroup.position.x;
            sunMesh.position.z = planeGroup.position.z - 4000;
        }

        // Blimp
        if(blimpGroup) {
            const t = Date.now() * 0.0002;
            blimpGroup.position.set(Math.cos(t)*600, 250, Math.sin(t)*600);
            blimpGroup.rotation.y = -t;
        }

        // UI
        uiSpeed.innerText = (speed * 100).toFixed(0);
        uiAlt.innerText = (planeGroup.position.y - 1.5).toFixed(0);
        uiStatus.innerText = planeGroup.position.y < 2 ? (speed>0.1?"TAXI":"DOCKED") : "AIRBORNE";

        // Cam
        const offset = new THREE.Vector3(0, 8, -30);
        const target = offset.applyMatrix4(planeGroup.matrixWorld);
        camera.position.lerp(target, 0.1);
        camera.lookAt(planeGroup.position);
    }

    // --- WORLD GENERATION ---
    function buildWorld() {
        // Ground (Black Mirror)
        const gMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.0, metalness: 0.8 });
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE), gMat);
        ground.rotation.x = -Math.PI/2;
        scene.add(ground);

        // Moving Grid (Cyan/Purple)
        // Size 6000, divisions 120 -> cell size 50
        gridHelper = new THREE.GridHelper(WORLD_SIZE, 120, C_PINK, 0x220044);
        gridHelper.position.y = 0.1;
        scene.add(gridHelper);

        // Runway (Solid Dark Strip)
        const rMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
        const runway = new THREE.Mesh(new THREE.PlaneGeometry(80, RUNWAY_LENGTH), rMat);
        runway.rotation.x = -Math.PI/2;
        runway.position.y = 0.2;
        scene.add(runway);
        
        // Runway Neon Edges
        const eMat = new THREE.MeshBasicMaterial({ color: C_CYAN });
        const e1 = new THREE.Mesh(new THREE.PlaneGeometry(2, RUNWAY_LENGTH), eMat);
        e1.rotation.x = -Math.PI/2; e1.position.set(-40, 0.3, 0); scene.add(e1);
        const e2 = new THREE.Mesh(new THREE.PlaneGeometry(2, RUNWAY_LENGTH), eMat);
        e2.rotation.x = -Math.PI/2; e2.position.set(40, 0.3, 0); scene.add(e2);

        // Retro Sun
        const sMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, fog: false });
        sunMesh = new THREE.Mesh(new THREE.CircleGeometry(300, 32), sMat);
        sunMesh.position.set(0, 200, -4000);
        scene.add(sunMesh);

        // Wireframe City (Optimized)
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const edgesGeo = new THREE.EdgesGeometry(boxGeo); // Create once!
        const bMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Occluder
        const lMat = new THREE.LineBasicMaterial({ color: C_PINK });

        for(let i=0; i<300; i++) {
            const h = 20 + Math.random()*150;
            const w = 10 + Math.random()*30;
            
            // Physics Box (Black)
            const b = new THREE.Mesh(boxGeo, bMat);
            b.scale.set(w, h, w);
            
            // Position
            let x = (Math.random()-0.5)*WORLD_SIZE;
            let z = (Math.random()-0.5)*WORLD_SIZE;
            if(Math.abs(x)<150 && Math.abs(z)<RUNWAY_LENGTH/1.2) x+=400; // Safe zone
            
            b.position.set(x, h/2, z);
            scene.add(b);

            // Wireframe Overlay
            const wFrame = new THREE.LineSegments(edgesGeo, lMat);
            wFrame.position.copy(b.position);
            wFrame.scale.copy(b.scale);
            scene.add(wFrame);
        }
    }

    // --- AIRCRAFT ---
    function spawnPlane(type) {
        if(planeGroup) scene.remove(planeGroup);
        currentStats = AIRCRAFT[type];
        planeGroup = new THREE.Group();
        currentStats.model(planeGroup, currentStats.color);
        planeGroup.position.set(0, 1.5, RUNWAY_LENGTH/2 - 200);
        planeGroup.rotation.set(0, Math.PI, 0);
        speed = 0;
        scene.add(planeGroup);
    }

    function createTrainer(g, c) {
        const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const line = new THREE.LineBasicMaterial({ color: c });
        
        // Body
        const bGeo = new THREE.ConeGeometry(2, 10, 4).rotateX(Math.PI/2);
        const b = new THREE.Mesh(bGeo, mat);
        b.add(new THREE.LineSegments(new THREE.EdgesGeometry(bGeo), line));
        g.add(b);

        // Wings
        const wGeo = new THREE.BoxGeometry(14, 0.1, 3);
        const w = new THREE.Mesh(wGeo, new THREE.MeshBasicMaterial({ color: c }));
        w.position.z = 1; g.add(w);

        // Tail
        const tGeo = new THREE.BoxGeometry(5, 0.1, 2);
        const t = new THREE.Mesh(tGeo, new THREE.MeshBasicMaterial({ color: c }));
        t.position.z = 4; g.add(t);

        // Engine
        g.add(new THREE.PointLight(c, 1, 10));
    }

    function createJet(g, c) {
        const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const line = new THREE.LineBasicMaterial({ color: c });
        
        const bGeo = new THREE.ConeGeometry(1.5, 14, 4).rotateX(Math.PI/2);
        const b = new THREE.Mesh(bGeo, mat);
        b.add(new THREE.LineSegments(new THREE.EdgesGeometry(bGeo), line));
        g.add(b);

        const wGeo = new THREE.ConeGeometry(7, 5, 4).rotateX(Math.PI/2).rotateY(Math.PI).scale(1.5, 0.1, 1);
        const w = new THREE.Mesh(wGeo, new THREE.MeshBasicMaterial({ color: c, wireframe:true }));
        w.position.set(0,0,1); g.add(w);
    }

    function createBiplane(g, c) {
        const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const line = new THREE.LineBasicMaterial({ color: c });

        const bGeo = new THREE.BoxGeometry(2,2,8);
        const b = new THREE.Mesh(bGeo, mat);
        b.add(new THREE.LineSegments(new THREE.EdgesGeometry(bGeo), line));
        g.add(b);

        const wGeo = new THREE.BoxGeometry(12,0.1,3);
        const w1 = new THREE.Mesh(wGeo, new THREE.MeshBasicMaterial({color:c})); w1.position.set(0,-0.5,-1); g.add(w1);
        const w2 = new THREE.Mesh(wGeo, new THREE.MeshBasicMaterial({color:c})); w2.position.set(0,2.5,-1); g.add(w2);
        
        const p = new THREE.Mesh(new THREE.BoxGeometry(6,0.1,0.5), new THREE.MeshBasicMaterial({color:0xffffff}));
        p.position.z=-4.2; g.add(p);
        g.userData.animate = () => { p.rotation.z += 0.5; };
    }

    function createBlimp() {
        blimpGroup = new THREE.Group();
        const bGeo = new THREE.SphereGeometry(30, 16, 16); bGeo.scale(1, 0.6, 0.6);
        const b = new THREE.Mesh(bGeo, new THREE.MeshBasicMaterial({ color:0x111111 }));
        b.add(new THREE.LineSegments(new THREE.EdgesGeometry(bGeo), new THREE.LineBasicMaterial({color: C_PINK})));
        blimpGroup.add(b);

        const gGeo = new THREE.BoxGeometry(12, 4, 4);
        const gondola = new THREE.Mesh(gGeo, new THREE.MeshBasicMaterial({ color: C_CYAN }));
        gondola.position.set(0, -18, 0); blimpGroup.add(gondola);

        const l = new FontLoader();
        l.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (f) => {
            const tGeo = new TextGeometry('CYBER CORP', { font: f, size: 4, height: 0.5 });
            tGeo.center();
            const tMat = new THREE.MeshBasicMaterial({ color: C_LIME });
            const t1 = new THREE.Mesh(tGeo, tMat); t1.position.set(0,0,16); blimpGroup.add(t1);
            const t2 = new THREE.Mesh(tGeo, tMat); t2.position.set(0,0,-16); t2.rotation.y=Math.PI; blimpGroup.add(t2);
        });
        scene.add(blimpGroup);
    }

    function animate() {
        requestAnimationFrame(animate);
        update();
        if(planeGroup && planeGroup.userData.animate) planeGroup.userData.animate();
        renderer.render(scene, camera);
    }
</script>
</body>
</html>